---
title: "Apply / Mapping tutorial"
author: "Derek Nagel"
date: "8/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Why should I use apply / map functions in R?

1. To save yourself work by avoiding code repetition
1. To make your scripts more memory efficient (faster)
1. To make your code more readable for others
1. To make your scripts flexible enough to handle more complex data and situations

## Vectorization

Many basic functions in R are *vectorized*, which means they can take vectors as input and perform a function on the elements of the vector one by one and return a vector of the results.


```{r vectorize 1}
c(1,2,3) + c(4,5,6)
```


A lot of basic functions work the same way including `+`, `-`, `*`, `/`, `^` as well as logical functions `==`, `<`, `>`, `&`, `|`


```{r vectorize 2}
c(1,2,3) == c(3,2,1)
```


If the vectors have different lengths (number of values), then R will *recycle* the smaller vector as many times as needed to produce a vector with the same length as the larger one. This is useful for multiplying all values in a vector by a single value.


```{r vectorize 3}
c(1,2,3) * 2
```


Be careful with this. If the vectors are different lengths and the smaller vector is not a single value, then R will repeat the smaller vector in order which may produce unexpected results.


```{r vectorize 4}
#Produces message
c(1,2,3) + c(4, 6)
#No message
c(1,2,3,4) + c(4, 6)
```


Most simple functions that take vectors as input and return vectors as output are vectorized for us which is convenient, but functions that take or return more complex objects such as data frames are usually not vectorized. This is where the `apply` family of functions comes in.

## Apply

`apply` takes a matrix or data frame and performs a function on each row or each column of the input individually. The first argument is a data frame or matrix, the second argument is the dimension to apply a function to (1 for rows, 2 for columns), and the third argument is the function to will be performed on each row or column. You can provide additional arguments which are then passed on to the function such as na.rm = T.


```{r apply 1}
a <- data.frame(c1 = 1:3, c2 = 4:6, c3 = c(7, 8, NA))
a
#Row products
apply(a, 1, prod, na.rm = T)
#Column products
apply(a, 2, prod, na.rm = T)
```


Alternatively, you can define an *anonymous function* which is basically a one-time function to use in an apply function.


```{r apply 2}


a <- data.frame(c1 = 1:3, c2 = 4:6, c3 = c(7, 8, NA))
a
#Row products
apply(a, 1, function(x) {prod(x, na.rm = T)})
#x is the convention for the object in the function, but you can name it anything you want
apply(a, 1, function(derek) {prod(derek, na.rm = T)})
#Subtract every value from last value in column
apply(a, 2, function(x) {dplyr::last(x) - x})
```


Usually there are better alternatives to `apply`. `RowSums`, `ColSums`, `RowMeans`, and `ColMeans` are shortcuts for taking the sums or means of all rows or columns. `mutate_all` and `summarize_all` from the dplyr / tidyverse packages are usually better for column-wise operations on data frames.

## lapply

`lapply` takes a vector or a list and performs a function on each item element of that vector or list. The output is a list with each item in the output list corresponding to the item in the input in the same position (i.e. the second item in the output list corresponds to the second item in the input). Lists can contain any type of object (including other lists), so `lapply` is extremely versatile.


```{r lapply 1, eval = F}

library(curl)
library(urltools)
library(pdftools)
library(rebus)
library(tidyverse)
library(lubridate)

read_cems <- function(pdf_file) {
  
  #read in pdf text
  cems_text <- pdf_text(pdf_file)
  
  #Extract dates from text
  
  #Look for "Date of Run..." until end of line
  dates <- str_extract_all(cems_text, "Date of Run" %R% any_char(1, Inf) %R% "\\r\\n") %>%
    #Extract all mm/dd dates with a preceding space
    str_extract_all(SPC %R% digit(1,2) %R% "/" %R% digit(1,2)) %>%
    unlist %>%
    str_trim %>%
    #Convert to date with year 2020
    {mdy(paste(., 2020))}
  
  #Extract emissions from text
  
  #Extract 4 lines after "LB/HR"
  emit_rates <- str_extract_all(cems_text, "LB/HR" %R% spc(1, Inf) %R% any_char(1, Inf) %R%
                                  spc(1, Inf) %R% any_char(1, Inf) %R%
                                  spc(1, Inf) %R% any_char(1, Inf) %R%
                                  spc(1, Inf) %R% any_char(1, Inf)) %>%
    #Look for line containing with "THC as Trans-1,2-"
    str_extract_all("THC as Trans-1,2-" %R% any_char(1, Inf)) %>%
    #Extract all numbers including decimal separator
    str_extract_all(digit(1, Inf) %R% DOT %R% digit(0, Inf)) %>%
    unlist %>%
    as.numeric %>%
    #Keep only values associated with a date and remove average column
    head(length(dates))
  
  #Create table of dates and values
  tibble(date = dates, emit_rate = emit_rates)
}

#Get file list from github repository; looking for shortcut. Use list.files for local directory
repository <- "https://github.com/MPCA-data/tidytuesdays/tree/master/show-n-tell/strings/water_gremlin_cems"

file_list <- curl_fetch_memory(repository)
file_list <- rawToChar(file_list[["content"]]) %>%
  str_extract_all('title=\\"' %R% any_char(1, Inf) %R% '.pdf" ') %>%
  unlist() %>%
  str_replace_all('title=\\"|\\" ', "")

url_list <- paste0("https://github.com/MPCA-data/tidytuesdays/raw/master/show-n-tell/strings/water_gremlin_cems/", url_encode(file_list))

#Test on first file
cems_data <- lapply(url_list[1], read_cems)

#Read all files using lapply
cems_data <- lapply(url_list, read_cems)

#Use bind_rows (dplyr) to merge list into one data frame
cems_data <- bind_rows(cems_data)

```


## Shortcuts for other files

If you are just reading files in a local directory you can use `lapply` with `list.files` and ``read_csv` (or another read function for different types of files).


```{r lapply 2, eval = F}
library(tidyverse)

dir <- "" #Paste directory name here
data <- lapply(list.files(dir, full.names = T), read_csv) %>% bind_rows()
```

For reading in csv, txt, or excel files, you can alternatively use `vroom` from the vroom package (they are the same name vroom::vroom) or `import` from the rio package which automatically combine your data into a single data frame (unless you tell them not to) without needing to call lapply or bind_rows.

## purrr

The purrr package is part of the tidyverse package. It contains a lot of apply style functions beyond what is included in base R.

## map

`map` is an enhanced lapply. `map` works like `lapply` does, but it also has some extra features. In particular, instead of providing a function as the second argument, we can provide an expression starting with `~` and refer to the element we are using with `.` or `.x`.


```{r map1, eval = F}
library(curl)
library(urltools)
library(pdftools)
library(rebus)
library(tidyverse)
library(lubridate)

#Define function to parse pdf files
read_cems <- function(pdf_file) {
  
  #read in pdf text
  cems_text <- pdf_text(pdf_file)
  
  #Extract dates from text
  
  #Look for "Date of Run..." until end of line
  dates <- str_extract_all(cems_text, "Date of Run" %R% any_char(1, Inf) %R% "\\r\\n") %>%
    #Extract all mm/dd dates with a preceding space
    str_extract_all(SPC %R% digit(1,2) %R% "/" %R% digit(1,2)) %>%
    unlist %>%
    str_trim %>%
    #Convert to date with year 2020
    {mdy(paste(., 2020))}
  
  #Extract emissions from text
  
  #Extract 4 lines after "LB/HR"
  emit_rates <- str_extract_all(cems_text, "LB/HR" %R% spc(1, Inf) %R% any_char(1, Inf) %R%
                                  spc(1, Inf) %R% any_char(1, Inf) %R%
                                  spc(1, Inf) %R% any_char(1, Inf) %R%
                                  spc(1, Inf) %R% any_char(1, Inf)) %>%
    #Look for line containing with "THC as Trans-1,2-"
    str_extract_all("THC as Trans-1,2-" %R% any_char(1, Inf)) %>%
    #Extract all numbers including decimal separator
    str_extract_all(digit(1, Inf) %R% DOT %R% digit(0, Inf)) %>%
    unlist %>%
    as.numeric %>%
    #Keep only values associated with a date and remove average column
    head(length(dates))
  
  #Create table of dates and values
  tibble(date = dates, emit_rate = emit_rates)
}

#Get file list from github repository; looking for shortcut. Use list.files for local directory
repository <- "https://github.com/MPCA-data/tidytuesdays/tree/master/show-n-tell/strings/water_gremlin_cems"

file_list <- curl_fetch_memory(repository)
file_list <- rawToChar(file_list[["content"]]) %>%
  str_extract_all('title=\\"' %R% any_char(1, Inf) %R% '.pdf" ') %>%
  unlist() %>%
  str_replace_all('title=\\"|\\" ', "")

url_list <- paste0("https://github.com/MPCA-data/tidytuesdays/raw/master/show-n-tell/strings/water_gremlin_cems/", url_encode(file_list))

#Same as lapply
cems_data <- map(url_list, read_cems)

#Add the file name as a column to the data
cems_data <- map(url_list, ~ read_cems(.x) %>% mutate(url = .x)) %>%
  bind_rows()

#Same example as above, but use {} for a multi-line expression
cems_data <- map(url_list, ~{data <-read_cems(.)
data <- mutate(data, url = .)
}) %>%
  bind_rows()

#map_dfr will automatically bind the list into a data frame without calling bind_rows
cems_data <- map_dfr(url_list, read_cems)
```


There are many more map variants. `map2` allows you to create an expression using values from two different lists or vectors. `pmap` allows you to use any number of lists and/or vectors to map on which is a great replacement for nested `for` loops.

## Grouped operations 
The dplyr and purrr packages allow you to split up your data by group with `group_by` and use functions on each group. `mutate` and `summarize` automatically apply the function to each group individually of a grouped data frame. They are useful for a lot of things, but the limitation of these functions is that they can only produce vectors and always return a data frame. purrr has functions `group_map`, `group_modify` and `group walk` which are much more flexible. `group_map` takes a grouped data frame, applies a function to each group, and returns a list of outputs for each group.


```{r group_map}
#View data
head(iris)

iris_plots <- iris %>%
  group_by(Species) %>%
  group_map(
    ~ggplot(.x, aes(Petal.Length, Petal.Width)) +
      geom_point() +
      labs(title = paste("Petal length vs. petal width of", .y$Species)) +
      theme_classic()
  )

iris_plots
```


`group_walk` works similar to `group_map` except that it returns your original data frame instead of the function output. This is useful when you want to save plots or write data by group but don't want to keep any output from the function.


```{r group_walk, eval = F}

save_to <- "//pca.state.mn.us/sdrive/Public/Nagel_Derek.DN/R plots" #Change directory

iris %>%
  group_by(Species) %>%
  group_walk(
    ~{ggplot(.x, aes(Petal.Length, Petal.Width)) +
      geom_point() +
      labs(title = paste("Petal length vs. petal width of", .y$Species)) +
      theme_classic()
      
      ggsave(paste0(save_to, "/Petal length vs petal width of ", .y$Species, ".png"))
    }
  )
```


## mutate / summarize all / at / if

dplyr has several functions that quickly apply other functions to many columns of a data frame at once.

Mutate all and summarize all take one or more functions and apply them to all columns of a data frame.

```{r mutate_all 1}
head(mtcars)

#Round all columns
mtcars %>% mutate_all(round)

#Get mean of all columns
mtcars %>% summarize_all(mean)

#Get min and max of all columns by providing a list
mtcars %>% summarize_all(list(min = min, max = max))

#If you use group_by first, summarize_all does not apply to grouping columns and applies by group
mtcars %>% group_by(cyl) %>% summarize_all(list(min = min, max = max))

#Can do more complex operations using ~ and . to refer to columns
mtcars %>% group_by(cyl) %>% summarize_all(list(range = ~max(.) - min(.)))
```
mutate_if and summarize_if are similar to the _all variants, but only apply the function to columns that meet a *predicate* condition such as `is.numeric`.


```{r mutate_if}
head(iris)

iris %>% mutate_if(is.numeric, round) %>% head() #Only show 6 rows

iris %>% summarize_if(is.numeric, list(avg = mean, med = median))
```

mutate_at and summarize_at are similar, but let you explicitly choose which columns to apply a function to.

```{r mutate_at}

head(mtcars)

#Choose columns by position
mtcars %>% summarize_at(c(1, 3:7), list(avg = mean, med = median))

#Or use vars() to select values as you would with select()
mtcars %>% summarize_at(vars(mpg, disp:qsec), list(avg = mean, med = median))

#Works by group as well
mtcars %>% group_by(cyl) %>% summarize_at(vars(mpg, disp:qsec), list(avg = mean, med = median))
```


## for loops

`for` loops are not a bad thing, but there are often better options. If you're trying to...

1. read multiple files: use `lapply`, `map`, `map_dfr`, `vroom`, or `import`
1. split a data frame into groups and do something to each group such as fit a model or create a plot: use `group_map`, `group_modify`, or `group_walk`
1. apply one or more functions to multiple columns in a data frame: use `mutate_at`, `mutate_if`, `mutate_all`, `summarize_at`, `summarize_if`, `summarize_all`

`for` loops are useful when you are doing something iterative where the input of one run depends on the output of a previous run.


```{r for}
#Random walk example
n <- 100
x <- 0
#Do n steps
for(i in 1:n) {
  #Randomly add -1 or 1 to previous result
  x[i+1] <- x[i] + sample(c(-1, 1), 1) #x[i+1] <- value is more memory efficient than x <- c(x, value)
}

#Create data frame with time t and position x
walk_data <- data.frame(t = 0:100, x)

#Plot data
ggplot(walk_data, aes(t, x)) +
  geom_line() +
  theme_classic()

#If all you care about is the final destination, sapply or map is easier
sum(sapply(1:n, function(x) sample(c(-1, 1), 1)))
sum(map_dbl(1:n, ~sample(c(-1, 1), 1)))
```

